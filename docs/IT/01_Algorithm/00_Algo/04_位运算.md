# variable-precision SWAR 算法

统计一个位数组中非0二进制位的数量（也称作计算汉明重量）。

variable-precision SWAR 算法在常数时间算出多个字节的汉明重量，且不需额外的内存。一共分 4 步：

``` C++
uint32_t swar(uint32_t i){
    i = (i & 0x55555555) + ((i>>1) & 0x55555555);  // 步骤1
    i = (i & 0x33333333) + ((i>>2) & 0x33333333);  // 步骤2
    i = (i & 0x0F0F0F0F) + ((i>>4) & 0x0F0F0F0F);  // 步骤3
    i = (i * 0x01010101) >> 24;                    // 步骤4
    return i;
}
```

主要采用分治的思想：

## 步骤1

使用 0x55555555 作为掩码，5的二进制表示为 0101，i & 0x55555555 得到了奇数位的值，(i>>1) & 0x55555555 得到了偶数位的值，两者相加，和的值在 \[0, 2\]，刚好用2bit 存。

## 步骤2

使用 0x33333333 作为掩码，3的二进制表示为 0011， i & 0x33333333 得到了以 2bit 分割的序列的奇数位的值，同理 (i>>2) & 0x33333333 得到偶数位的值，两者相加，和的值在 \[0, 4\]，用3bit 存就够了，这里用4bit 存。

## 步骤3

与前两步相同，这里掩码为 0x0F0F0F0F。最终剩下 4 个8bit的值，表示这 8bit 上1的个数。

## 步骤4

将上一步产生的 4个 8bit 值相加，得到最终答案。

(i & 0xFF) + ((i >> 8) & 0xFF) + ((i >> 16) & 0xFF) + ((i >> 24) & 0xFF)

* 0x01010101 = (1 << 24) + (1 << 16) + (1 << 8) +1
* i\*0x01010101 = (i << 24) + (i << 16) + (i << 8) +i
* 最后高8位即为最终的和

