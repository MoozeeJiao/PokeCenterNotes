# 《深入理解JVM》

#内存自动管理

## 第二章 Java内存区域与内存溢出异常

### 运行时数据区域

线程私有: 

1. 程序计数器: Program Counter Register 
 * 当前线程所执行的字节码的行号指示器。
 * 如果执行的是java方法，记录虚拟机字节码指令地址；如果执行的是Native方法，值为空。
 * 唯一一个没有规定OOM情况的区域。

2. Java虚拟机栈: VM stack
* 生命周期与线程相同，线程内存模型。
* 每个方法执行的时候，虚拟机会同步创建一个栈帧 stack frame，用于存储局部变量表、操作数栈、动态连接、方法出口等信息。
* 方法生命周期对应着一个栈帧从入栈到出栈的过程。
* 局部变量表中放了编译期可以知道的: java基本类型、对象引用、returnAddress类型。
* 局部变量表的空间以槽slot表示，64长度的long和double占两个槽，其他一个。槽的数量在编译期间完成分配，不会在运行时改变。
* 请求栈帧深度大于虚拟机允许: StackOverFlow。
* 申请栈空间失败: OOM（32位线程过多）

3. 本地方法栈: Native Meth Stacks
* 与虚拟机栈类似，虚拟机栈服务字节码，本地方法栈服务本地方法。
* hostspot等把这两个栈二合一。

所有线程共享

 4. 堆: Heap
* 几乎所有对象、数组都在堆上创建。
* 是垃圾收集器管理的区域，经典垃圾收集器经常分代。
* 堆中会划分出多个线程私有的分配缓冲区，以提升对象分配时的效率。
* 没有内存完成分配，且堆无法再扩展是，抛出OOM（内存泄露，参数设置，设计问题）

5. 方法区: Method Area
* 存储已被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等。
* hotspot JDK8后 Metaspace
* 需要常量池的回收和类型的卸载。
* 无法分配空间时OOM（参数设置，类太多无限动态代理）

6. 运行时常量池: Runtime Constant Pool
* 方法区的一部分。class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表，用于存放编译期生成的各种字面量与符号引用，这部分放在常量池。
* 除class中的符号引用外，翻译出的直接引用也会放到常量池。
* 运行时也可以把新常量放入池中，比如string的intern()
* 无法分配空间时OOM

7. 直接内存: Direct Memory
* 不是虚拟机运行时数据区的一部分。
* jdk1.4引入NIO，一种基于channel和buffer的io技术。使用native方法直接分配堆外内存，通过堆中DirectByteBuffer作为堆外内存的引用进行操作。避免了java堆和native堆之间的拷贝。
* 与jvm内存加起来不能超过物理内存，容易导致jvm中内存OOM（dump出来内存很少）

### 对象

1. 创建

遇到new指令 -> 常量池类加载检查 -> 堆中分配内存 -> 设置对象头 -> 执行构造方法

内存分配时的并发安全有两种方法保证:
* CAS+重试，保证原子性；
* 每个线程预先分配一小块内存，本地线程分配缓冲 ThreadLocalAllocationBuffer。缓冲区满了分配新缓冲区才会同步锁定。-XX:+/-UseTLAB

2. 内存布局
* 对象头 Header: 第一类运行时数据 Mark Word，动态定义的数据结构，尽可能用小空间存更多的定义。

|存储内容|标志位|状态|
|---|---|---|
|对象hashCode，分代年龄|01|未锁定|
|指向锁记录的指针|00|轻量级锁定|
|指向重量级锁的指针|10|膨胀（重量级锁定）|
|空|11|gc标记|
|偏向线程id，偏向时间戳，分代年龄|01|可偏向|

第二类类型指针，数组的话有长度。
* 示例数据 Instance Data: 各字段内容，受虚拟机分配策略和定义顺序影响，相同宽度的字段总放在一起。窄变量会插在空隙中。
* 对齐填充 Padding: 对象其实地址必须是8字节的整数倍，对象长度也就必须是8字节的整数倍。

3. 访问定位
* 句柄式: 栈上refrence -> 句柄池，堆（到实例的指针 -> 对象实例，堆；类型指针 -> 对象类型，方法区）

* 直接指针式: 栈上refrence -> 对象实例，堆 -> 对象类型，方法区

## 第三章 垃圾收集器与内存分配策略

程序计数器和虚拟机栈都随线程生命周期，分配回收都有确定性。堆和方法区具有不确定性，处于运行期间才能确定分配和回收。

### 判断对象已死

1. 引用记数法

引用时加一，引用失效减一。无法处理互相引用。

2. 可达性分析

gc root不可达就回收。

gc root: 
* 虚拟机栈中引用的变量，参数、局部变量、临时变量；
* 静态属性引用的对象；
* 常量引用对象；
* 本地方法栈native方法引用的对象；
* 虚拟机内部引用，如常驻异常对象，系统类加载器；
* 同步锁持有的对象；
* jmxbean，jvmti 中注册的回调和本地代码缓存。
* 局部回收时，堆别的区域。

引用:
* 强引用 strongly reference: 引用赋值，不会被回收；
* 软引用 soft reference: 有用非必要，发生oom前回收；
* 弱引用 weak reference: 非必要，只生存到下次gc；
* 虚引用 phantom reference: 被回收时会有系统通知。

没有gc root被标记一次，如有finalize方法放入队列。等执行完finalize（一个对象只会被执行一次）再标记一次。

## 垃圾收集算法

1. 分代收集 Generational Collection：

假说：
* 大多数对象朝生夕灭；
* 熬过越多次gc的对象越难被回收；
* 跨代引用只占极少数。

把不同年龄的对象放在一起。新生代，老年代。新生代上有全局数据结构记忆集，标识出老年代哪里会有跨代引用。

    1. 标记清除算法 Mark-Sweep
        标记出要清除的对象，统一回收。效率不稳定，容易产生内存碎片。
        
    2.标记复制算法 Semispace Copying
        将内存分为两半，每次内存用完了就将还存活的对象复制到另一半。空间利用率低。
        
        Apple式回收：将新生代分为一个Eden区（8）和两个Survivor区（1）。
        分配内存只在Eden和一块Survivor，回收时存活对象复制到另一个Survivor。
        内存利用率90%。如果回收时空间不够用就要借助老年代。
        
    3. 标记整理算法
        将所有存活对象向内存一侧移动，直接清理边界外的。
        降低内存碎片，降低内存分配时间。
        垃圾回收时间和复杂度增加。

内存分配时间影响吞吐率。parallel scavenge
垃圾回收时间延迟。CMS 平时标记清除，碎片率太大时标记整理。

## HotSpot的算法实现细节

1. 根节点枚举

目前这一步所有收集器都要暂停用户线程。

利用oopMap，准确式收集。

2. 安全点

程序必须执行到安全点才能gc。方法调用，循环跳转，异常跳转等让程序长时间运行的地方。

所有线程都要运行到安全点: 
* 抢先式: 先全中断，没到安全点的再跑起来；
* 主动式: 轮询一个标志位，轮询的地方是和安全点重合的，还有要分配内存的地方。

3. 安全区域

有的线程不在执行，没法主动去安全点。安全区域指某一段代码片段内引用关系不再发生变化。

这个区域内任意位置开始gc都是安全的。离开时检查是否完成根节点枚举，否则一直等待。

4. 记忆集与卡表

记忆集指记录非收集区指向收集区的指针的集合。避免遍历整个非收集区。

通过粗粒度记录来降低存储和维护成本:
* 字节精度
* 对象精度
* 卡精度

卡表就是记忆集卡精度的一种实现。卡表每个元素对应内存中一块2的n次密的区域卡页。一个卡页中有多个对象，只要有一个跨代指针，卡表元素就变脏。把脏的卡表对应卡页加入gc root扫描。

5. 写屏障

对引用类型字段赋值的切面。写后屏障中维护卡表状态。

伪共享问题：同时更新一个缓存行，可选对策为写屏障增加条件。

6. 并发可达性分析

三色标记: 
* 白色: 未被访问。gc开始时所有对象都是白色。如果结束时还是白色说明不可达。
* 黑色: 已被访问，且所有引用都被扫描了。不可能直接指向白色。
* 灰色: 已被访问过，但是还有引用未被扫描。

用户线程和扫描线程同时并行，会改变图结构，让本应该是黑色最终是白色：
* 插入黑色到白色的新引用;
* 删除全部灰色到该白色的直接或间接引用。

破坏这两条件之一即可:
* 增量更新 Incremental Update: 当插入新的黑到白引用时，将引用记录下来最后再扫描一遍;
* 原始快照 Snapshot At The Beginning: 删除灰到白引用时，将引用记录下来最后再扫描一遍。

都通过写屏障实现。










