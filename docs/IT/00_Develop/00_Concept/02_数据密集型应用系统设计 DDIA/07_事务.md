# 7.事务

应用程序和数据库之间的连接是不稳定的，多个应用会对数据库某个资源进行竞争。

事务是简化这些问题的首选机制。其目的是简化应用层的编程模型。

*事务将应用程序的多个读写操作捆绑在一起成为一个逻辑操作单元。整个事务要么成功要么失败。*

## ACID的含义

事务所提供的安全保障: Atomicity, Consistency, Isolation, Durability 各家数据库对其实现不尽相同，存在很多含糊不清的争议。

BASE 基本可用、软状态、最终一致性，这些不是 ACID。

### 原子性

在出错时终止事务，并将部分完成的写入全部丢弃。

###  一致性

数据库处于应用程序所期待的“预期状态”。

一致性要求应用层来维护状态的一致，不属于数据库自身的属性。

### 隔离性

确保事务在同时运行时其结果与串行执行完全相同。

### 持久性

一旦事务提交，即使存在硬件故障或数据库崩溃，事务所写入的任何数据都不会丢失。

## 单对象与多对象事务操作

### 单对象写入

在单节点、单对象层面上提供原子性、隔离性。

通常意义上事务是针对多个对象，将操作聚合成为一个逻辑执行单元。

### 多对象事务的必要性

跨分区多对象事务往往较难实现。但如果没有事务，没有原子性保障，错误处理就会异常复杂；没有隔离性保障，容易在并发方面出现奇怪的问题。

### 处理错误与终止

事务的一个关键特性是，如果发生了意外，所有操作被中止，之后可以安全的重试。

支持安全的重试机制才是中止流程的重点。

重试时要考:
* 虑幂等性；
* 系统压力；
* 永久性故障；
* 数据库之外影响；
* 重试失败

等因素

## 弱隔离级别

非串行化就是弱隔离。弱隔离也是关系型数据库的主流。串行化会严重影响性能。

## 读-提交

1. 读数据库，只能看到已成功提交的数据（防止脏读）

	一个事务可以看到另一个事务未提交的数据就是脏读。

	如果事务涉及到多个对象，脏读会导致用户观测到部分更新；如果事务发生中止，用户将看到一些稍后会回滚的数据。

2. 写数据库，只会覆盖已成功提交的数据（防止脏写）

	对于同一个数据，后来的事务写覆盖先来的事务写。如果先来的事务未提交，则发生脏写。通常的解决方式是推迟后来的写请求，直到先来的提交了。

	*读-提交隔离不能解决计数器增量竞争*

3. 实现

	读-提交隔离是很多数据库的默认隔离级别。

	通常采用行级锁来防止脏写。

	也可以用锁来防止脏读，但是读锁影响响应延迟，任何局部性能问题都有可能扩散影响整个应用程序。因此大多数数据库会对每个待更新对象，维护其旧值和当前持锁事务将要设置的新值两个版本。其他读操作都是取旧值，事务提交后才取新值。

## 快照隔离级别与可重复读

不可重复读:一个事务读的过程中，已经读到了A,另一个事务对数据B进行了修改，读事务再读B时A,B两数据属于不同版本。

快照级别隔离是解决不可重复读的主流手段。

每个事务都从数据的一致性快照读取，保证一个事务只读一个时间点的旧数据。

### 实现快照级别隔离

行级锁防止脏写。

多版本并发控制（Multi Version Concurrency Control MVCC）:

* 在读-提交级别下，对每一个不同的查询单独创建一个快照；
* 在快照隔离级别下，使用一个快照来运行整个事务。

当事务开始时赋予一个唯一的单调递增的事务id。每当事务向数据库写入新内容时，所写数据会被标记写入者的事务id。表中每一行都有一个created_by字段，和一个初始为空的deleted_by字段。当确定没有其他事务引用有删除标记的行后，数据库的垃圾回收进程才去真正释放存储空间。

一致性快照的可见性通过事务id决定。可见的条件:
* 事务开始的时刻，创建该对象的事务已经提交；
* 对象没有被标记为删除；或者标记了但是删除事务在当前事务开始时还没有提交。

### 索引与快照级别隔离

PostgreSQL把同一对象的不同版本放在一个内存页面上，避免更新索引。

其他以b树为主体结构的数据库，利用一种追加/写时复制的技术，创建一个新的修改副本，每一个写入事务有自己的树根，查询时无需再根据事务id进行过滤。

### 命名混淆

* Oracle的串行化是可重复读；
* DB2的可重复读是串行化。

## 防止更新丢失

read-modify-write，并发写事务冲突。

### 原子写操作

数据库层面提供原子写操作，避免读-修改-写回。通常通过对对象施加独占锁实现，另一种是现实方式是强制所有原子操作都在单线程上执行。

原子写操作是推荐的最佳方式。

### 显示加锁

select ... for update; 可以对返回的对象加锁。

### 自动检测更新丢失

让并发写操作执行，如果事务管理器检测到了更新丢失风险，则会终止当前事务，并强制退回到安全的方式。

* Oracle,PostgreSQL,SQL Server都支持；
* Mysql不支持。

### 原子比较和设置

很多不支持事务的数据库支持原子的比较和设置操作，只有在上次读取到的数据没有发生变化的时候才允许更新。

使用时请先检查比较和设置操作的安全运行条件，如事务运行在某个旧快照上，就无法防止更新丢失。

### 冲突解决与复制

对于多副本数据库，并发写时加锁和原子比较不再适用。通常保留多个冲突版本，之后由应用逻辑或依靠特定的数据结构来解决、合并多个版本。

如果操作是顺序无关的，那么原子操作在多副本情况下也可以工作。

## 写倾斜与幻读

写倾斜：两个事务同时读一组对象，然后更新其中的一部分；不同事务更新不同对象则有可能写倾斜；更新同一个对象则可能脏写或更新丢失。

1. 首先输入匹配条件，采用select找出匹配的行；
2. 根据查询结果决定下一步操作；
3. 如果继续执行，则进行写。

幻读：一个事务中的写改变了另一个事务查询结果。

快照级别隔离只能解决只读事务的幻读，读-写事务的幻读解决不了。

### 实体化冲突

如果查询结果是空，则引入一些对象来加锁。把幻读转换为数据库中一组具体行的锁冲突问题。

不推荐这种方法，串行化隔离方案更加可行。

## 串行化

保证即使事务可能会并行执行，但最终结果与每次一个的串行执行结果相同。目前基本上都是以下三种技术：

1. 严格按照串行顺序执行；
2. 两阶段锁（几十年来唯一可行的选择）；
3. 乐观并发控制技术，例如可串行化的快照隔离。

### 实际串行执行

在一个线程上按顺序执行事务。

* 内存越来越便宜
* OLTP读多写少

#### 采用存储过程封装事务

为了节省网络开销，提高吞吐量。单线程串行执行的数据库往往不支持交互式的多语句事务。而是将整个事务代码当做存储过程打包给数据库。

* 传统数据库存储过程，难调试，性能问题；
* 新的直接用编程语言: voltDB java，Redis Lua

#### 分区提高吞吐量

#### 串行执行条件

* 事务必须简洁高效，否则缓慢执行的事务会影响其他事物；
* 仅限于活动数据集可以完全加载到内存的情况；
* 写入吞吐量必须低；否则要分区；
* 跨分区事务可以支持，但必须占比很小。

### 两阶段加锁

近三十年来唯一被广泛应用的串行化方法。

* 并发写操作之间互斥；
* 读取和修改之间互斥。

目前应用于MySQL InnoDB和 sqlserver的可串行化隔离，db2的可重复读隔离。

#### 实现2PL

每个对象都有一个读写锁来隔离操作，锁可以是共享的也可以是独占的。


基本使用方法：

* 如果事务要读取对象，必须先获得共享锁。可以多个事务同时获得一个对象的共享锁。但如果对象被上了独占锁，其他事务就得等待。
* 如果事务要修改对象，必须先获得独占锁。
* 如果事务先读对象然后尝试写入对象，则共享锁要升级成独占锁。锁升级等价于直接获取独占锁。
* 锁会持有到事务结束（第一阶段获取锁；第二阶段释放锁）。

#### 两阶段加锁性能

性能不好：锁的获取和释放；竞争时的等待；死锁。

#### 谓词锁

防止幻读

* 如果事务A想select 他必须以共享模式获得查询条件的谓词锁。如果B有任何一个匹配条件的独占锁，A必须等待。
* 如果A想要修改任何对象，必须检查旧值与新值是否与任何谓词锁匹配，如果匹配必须等待。

#### 索引区间锁

谓词锁性能不加，索引区间锁是他的简化。

其方式是将保护对象扩大化，这样与原先谓词冲突的操作肯定也与扩大的范围冲突。

将共享锁加到索引上，如果查询条件附近有修改就会与共享锁冲突。

如果没有合适的索引加区间锁，则回退到对整个表加共享锁。

### 可串行化的快照隔离

尚在证明中，PostgreSQL 9.1以后的可串行化隔离。

#### 悲观与乐观的并发控制

2pl是悲观并发控制机制，如果操作可能出错就直接放弃。

在快照隔离的基础上，SSI增加了相关算法来检测写入之间的串行化冲突，从而决定中止哪些事务。

#### 基于过期的条件做决定

数据库必须检测事务是否会修改其他事物的查询结果。

1. 检测是否读取了过期的MVCC对象

	当事务提交时，数据库会检查是否存在一些当时读取时被忽略的写操作现在已经完成提交，如果是的话则必须中止当前事务。

2. 检测写是否影响了之前的读

	类似于索引区间锁，数据库可以通过索引记录哪些事务来进行了读操作（也可以在表级）。当一个事务尝试修改时，会先查索引，从而得到哪些事务读了这些数据，以在这些事务提交时通知他们回滚。

#### 可串行化快照隔离性能

* 记录元数据会增加开销，取决于工程实现细节；
* 与2pl相比，优势是不用等其他事务的锁；
* 可以突破单个cpu核的限制，运用于多个分区上；
* 中止比例会显著影响性能。