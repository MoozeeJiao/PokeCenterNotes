# 高并发设计指南

## 一、设计原则

前提：
* 高可用
* 可以水平扩展
* 数据异构

分两步走：
* 进行高并发评估，再进行高可用评估（业务指标；应用层、服务层、数据层高可用）
* 性能评估（指标、并发用户数、TPS 高于1000分布式，低于单体加速）

## 二、设计指引

计算一下峰值并发用户数

* 99小于200ms（用户无感）
* 999小于1s（用户可接受）

高可用主要手段：
* 数据、服务的冗余
* 失效情况下的转移

将两个相同组件并联，可以大大提高可用性

A=MTBF/(MTBF+MTTR)

A=1-(1-Ax)^2

* 应用层：无状态、可扩展、负载、业务状态集群；
* 服务层：隔离、限流、超时、异步、降级、幂等、熔断；
* 数据层：数据备份、失效转移、异构存储。

linux线程数小于1000，tomcat线程数在150-1000容量4G，每个线程1M内存。所以TPS1000将打到单台机器性能上限

* 分布式架构演进：应用拆分，数据拆分，负载技术，海量数据库，微服务化，容器化
* 单应用加速：测定瓶颈，了解时空消耗，优化内存，替换高效语言，空间换时间

## 三、单应用响应加速

### 4. 内存优化：

* 内存溢出
    * 堆内存：-Xmx单个对象过大，对象过多；
    * 栈内存：-Xss大量局部变量、方法调用；
    * 永久代：-XX:MaxPermSize 存储类、方法区。大量使用反射、动态代理；
    * 本地内存：调用本地方法C/C++。
* 内存泄露
    * 静态变量：如引用对象，则对象会一直在内存中；
    * 单例模式：单例引用的对象不再使用了；
    * 软引用、弱引用、虚引用：gc前有特殊处理；
    * 未关闭流

### 5. 空间换时间

索引、缓存、池化、压缩、削峰（延迟、异步、节流、去抖）、批量

## 四、分布式架构演进

### 1. 应用拆分

缓存，反向代理

### 2. 数据拆分

读写分离，业务分离，大表拆分

### 3. 负载技术引入

使用lvs、f5负载多个nginx，dns轮询实现机房负载均衡


